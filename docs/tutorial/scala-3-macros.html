<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Scala 3 Macros · Scala 3 Macro Tutorial</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="[Inline methods][inline] provide us with a elegant technique for metaprogramming by performing some operations at compile time."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Scala 3 Macros · Scala 3 Macro Tutorial"/><meta property="og:type" content="website"/><meta property="og:url" content="https://lampepfl.github.io//scala3-macro-tutorial/index.html"/><meta property="og:description" content="[Inline methods][inline] provide us with a elegant technique for metaprogramming by performing some operations at compile time."/><meta property="og:image" content="https://lampepfl.github.io//scala3-macro-tutorial/img/dotty-logo.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://lampepfl.github.io//scala3-macro-tutorial/img/dotty-logo.svg"/><link rel="shortcut icon" href="/scala3-macro-tutorial/img/dotty-logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster&amp;display=swap"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Fira+Code:400,700&amp;display=fallback"/><script src="/scala3-macro-tutorial/js/scrollSpy.js"></script><link rel="stylesheet" href="/scala3-macro-tutorial/css/main.css"/><script src="/scala3-macro-tutorial/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scala3-macro-tutorial/"><img class="logo" src="/scala3-macro-tutorial/img/dotty-logo-white.svg" alt="Scala 3 Macro Tutorial"/><h2 class="headerTitleWithLogo">Scala 3 Macro Tutorial</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/scala3-macro-tutorial/docs/tutorial/introduction.html" target="_self">Tutorial</a></li><li class=""><a href="/scala3-macro-tutorial/docs/contributing.html" target="_self">Contribute</a></li><li class=""><a href="https://github.com/lampepfl/scala3-macro-tutorial" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorial</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorial</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/introduction.html">Introduction</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/inline.html">Inline</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/compile-time-operations.html">Scala Compile-time Operations</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/scala-3-macros.html">Scala 3 Macros</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">Quoted Code</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html">TASTy Reflection</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Extra</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/faq.html">FAQ</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/best-practices.html">Best Practices</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/other-recources.html">Other Recources</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/lampepfl/scala3-macro-tutorial/edit/master/docs/tutorial/macros.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Scala 3 Macros</h1></header><article><div><span><p><a href="/scala3-macro-tutorial/docs/tutorial/inline.html">Inline methods</a> provide us with a elegant technique for metaprogramming by performing some operations at compile time.
However, sometimes inlining is not enough and we need more powerful ways to analyze and synthesize programs at compile time.
Macros enable us to do exactly this: treat <strong>programs as data</strong> and manipulate them.</p>
<h2><a class="anchor" aria-hidden="true" id="macros-treat-programs-as-values"></a><a href="#macros-treat-programs-as-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Macros Treat Programs as Values</h2>
<p>With a macro, we can treat programs as values, which allows us to analyze and generate them at compile time.
A Scala expression with type <code>T</code> is represented by an instance of the type <code>scala.quoted.Expr[T]</code>.</p>
<p>We will dig into the details of the type <code>Expr[T]</code>, as well as the different ways of analyzing and constructing instances, when talking about <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">Quoted Code</a> and <a href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html">Reflection</a>.
For now, it suffices to know that macros are metaprograms that manipulate expressions of type <code>Expr[T]</code>.</p>
<p>The following macro implementation simply prints the expression of the provided argument:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inspectCode</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Any</span>])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Any</span>] =
  println(x.show)
  x
</code></pre>
<p>After printing the argument expression, we return the original argument as a Scala expression of type <code>Expr[Any]</code>.</p>
<p>As foreshadowed in the section on <a href="/scala3-macro-tutorial/docs/tutorial/inline.html">Inline</a>, inline methods provide the entry point for macro definitions:</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inspect</span></span>(inline x: <span class="hljs-type">Any</span>): <span class="hljs-type">Any</span> = ${ inspectCode(<span class="hljs-symbol">'x</span>) }
</code></pre>
<p>All macros are defined with an <code>inline def</code>.
The implementation of this entry point always has the same shape:</p>
<ul>
<li>they only contain a single <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">splice</a> <code>${ ... }</code></li>
<li>the splice contains a single call to the method that implements the macro (for example <code>inspectCode</code>).</li>
<li>the call to the macro implementation receives the <em>quoted</em> parameters (that is <code>'x</code> instead of <code>x</code>) and a contextual <code>QuoteContext</code>.</li>
</ul>
<p>We will dig deeper into these concepts later in this and the following sections.</p>
<p>Calling our <code>inspect</code> macro <code>inspect(sys error &quot;abort&quot;)</code> prints a string representation of the argument expression at compile time:</p>
<pre><code class="hljs">scala.sys.<span class="hljs-builtin-name">error</span>(<span class="hljs-string">"abort"</span>)
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="macros-and-type-parameters"></a><a href="#macros-and-type-parameters" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Macros and Type Parameters</h3>
<p>If the macro has type parameters, the implementation will also need to know about them.
Just like <code>scala.quoted.Expr[T]</code> represents a Scala expression of type <code>T</code>, we use <code>scala.quoted.Type[T]</code> to represent the Scala type <code>T</code>.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">logged</span></span>[<span class="hljs-type">T</span>](inline x: <span class="hljs-type">T</span>): <span class="hljs-type">T</span> = ${ loggedCode(<span class="hljs-symbol">'x</span>)  }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loggedCode</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>])(using <span class="hljs-type">Type</span>[<span class="hljs-type">T</span>], <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>] = ...
</code></pre>
<p>Both the instance of <code>Type[T]</code> and the contextual <code>QuoteContext</code> are automatically provided by the splice in the corresponding inline method (that is, <code>logged</code>) and can be used by the macro implementation.</p>
<h3><a class="anchor" aria-hidden="true" id="defining-and-using-macros"></a><a href="#defining-and-using-macros" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Defining and Using Macros</h3>
<p>A key difference between inlining and macros is the way they are evaluated.
Inlining works by rewriting code and performing optimisations based on rules the compiler knows.
On the other hand, a macro executes user-written code that generates the code that the macro expands to.</p>
<p>Technically, compiling the inlined code <code>${ inspectCode('x) }</code> calls the method <code>inspectCode</code> <em>at compile time</em> (through Java reflection), and the method <code>inspectCode</code> then executes as normal code.</p>
<p>To be able to execute <code>inspectCode</code>, we need to compile its source code first.
As a technicaly consequence, we cannot define and use a macro in the <strong>same class/file</strong>.
However, it is possible to have the macro definition and its call in the <strong>same project</strong> as long as the implementation of the macro can be compiled first.</p>
<blockquote>
<h4><a class="anchor" aria-hidden="true" id="suspended-files"></a><a href="#suspended-files" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Suspended Files</h4>
<p>To allow defining and using macros in the same project, only those calls to macros are expanded, where the macro has already been compiled.
For all other (unknown) macro calls, the compilation of the file is <em>suspended</em>.
Suspended files are only compiled after all non suspended files have been successfully compiled.
In some cases, you will have <em>cyclic dependencies</em> that will block the completion of the compilation.
To get more information on which files are suspended you can use the <code>-Xprint-suspension</code> compiler flag.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="example-statically-evaluating-power-with-macros"></a><a href="#example-statically-evaluating-power-with-macros" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Example: Statically Evaluating <code>power</code> with Macros</h3>
<p>Let us recall our definition of <code>power</code> from the section on <a href="/scala3-macro-tutorial/docs/tutorial/inline.html">Inline</a> that specialized the computation of <code>xⁿ</code> for statically known values of <code>n</code>.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">power</span></span>(x: <span class="hljs-type">Double</span>, inline n: <span class="hljs-type">Int</span>): <span class="hljs-type">Double</span> =
  inline <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> then <span class="hljs-number">1.0</span>
  <span class="hljs-keyword">else</span> inline <span class="hljs-keyword">if</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span> then x * power(x, n - <span class="hljs-number">1</span>)
  <span class="hljs-keyword">else</span> power(x * x, n / <span class="hljs-number">2</span>)
</code></pre>
<p>In the remainder of this section, we will define a macro that computes <code>xⁿ</code> for a statically known values <code>x</code> and <code>n</code>.
While this is also possible purely with <code>inline</code>, implementing it with macros will illustrate a few things.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">power</span></span>(inline x: <span class="hljs-type">Double</span>, inline n: <span class="hljs-type">Int</span>) =
  ${ evalPower(<span class="hljs-symbol">'x</span>, <span class="hljs-symbol">'n</span>)  }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">powerCode</span></span>(
  x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Double</span>],
  n: <span class="hljs-type">Expr</span>[<span class="hljs-type">Int</span>]
)(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Double</span>] = ...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="simple-expressions"></a><a href="#simple-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple Expressions</h2>
<p>We could implement <code>powerCode</code> as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pow</span></span>(x: <span class="hljs-type">Double</span>, n: <span class="hljs-type">Int</span>): <span class="hljs-type">Double</span> =
  <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> then <span class="hljs-number">1</span> <span class="hljs-keyword">else</span> x * pow(x, n - <span class="hljs-number">1</span>)

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">powerCode</span></span>(
  x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Double</span>],
  n: <span class="hljs-type">Expr</span>[<span class="hljs-type">Int</span>]
)(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Double</span>] =
  <span class="hljs-keyword">val</span> value: <span class="hljs-type">Double</span> = pow(x.unliftOrError, n.unliftOrError)
  <span class="hljs-type">Expr</span>(value)
</code></pre>
<p>Here, the <code>pow</code> operation is a simple Scala function that computes the value of <code>xⁿ</code>.
The interesting part is how we create and look into the <code>Expr</code>s.</p>
<h3><a class="anchor" aria-hidden="true" id="creating-expression-from-values"></a><a href="#creating-expression-from-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating Expression From Values</h3>
<p>Let's first look at <code>Expr.apply(value)</code>. Given a value of type <code>T</code>, this call will return an expression containing the code representing the given value (that is, of type <code>Expr[T]</code>).
The argument value to <code>Expr</code> is computed at compile-time, at runtime we only need to instantiate this value.</p>
<p>Creating expressions from values works for all <em>primitive types</em>, <em>tuples</em> of any arity, <code>Class</code>, <code>Array</code>, <code>Seq</code>, <code>Set</code>, <code>List</code>, <code>Map</code>, <code>Option</code>, <code>Either</code>, <code>BigInt</code>, <code>BigDecimal</code>, <code>StringContext</code>.
Other types can also work if a <code>Liftable</code> is implemented for it, we will <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">see this later</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="extracting-values-from-expressions"></a><a href="#extracting-values-from-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extracting Values from Expressions</h3>
<p>The second method we use in the implementation of <code>powerCode</code> is <code>Expr[T].unliftOrError</code>, which has an effect opposite to <code>Expr.apply</code>.
It attempts to extract a value of type <code>T</code> from an expression of type <code>Expr[T]</code>.
This can only succeed, if the expression directly contains the code of a value, otherwise, it will throw an exception that stops the macro expansion and reports that the expression did not correspond to a value.</p>
<p>Instead of <code>unliftOrError</code>, we could also use the <code>unlift</code> operation, which will return an <code>Option</code>.
This way we can report the error with a custom error message.</p>
<pre><code class="hljs css language-scala">  ...
  (x.unlift, n.unlift) <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(base), <span class="hljs-type">Some</span>(exponent)) =&gt;
      pow(base, exponent)
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Some</span>(_), _) =&gt;
      report.error(<span class="hljs-string">"Expected a known value for the exponent, but was "</span> + n.show, n)
    <span class="hljs-keyword">case</span> _ =&gt;
      report.error(<span class="hljs-string">"Expected a known value for the base, but was "</span> + x.show, x)
</code></pre>
<p>Alternatively, we can also use the <code>Unlifted</code> extractor</p>
<pre><code class="hljs css language-scala">  ...
  (x, n) <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Unlifted</span>(base), <span class="hljs-type">Unlifted</span>(exponent)) =&gt;
      pow(base, exponent)
    <span class="hljs-keyword">case</span> (<span class="hljs-type">Unlifted</span>(_), _) =&gt; ...
    <span class="hljs-keyword">case</span> _ =&gt; ...
</code></pre>
<p>The operations <code>unlift</code>, <code>unliftOrError</code>, and <code>Unlifted</code> will work for all <em>primitive types</em>, <em>tuples</em> of any arity, <code>Option</code>, <code>Seq</code>, <code>Set</code>, <code>Map</code>, <code>Either</code> and <code>StringContext</code>.
Other types can also work if an <code>Unliftable</code> is implemented for it, we will <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">see this later</a>.</p>
<h3><a class="anchor" aria-hidden="true" id="showing-expressions"></a><a href="#showing-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Showing Expressions</h3>
<p>In the implementation of <code>inspectCode</code>, we have already seen how to convert expressions to the string representation of their <em>source code</em> using the <code>.show</code> method.
This can be useful to perform debugging on macro implementations:</p>
<pre><code class="hljs css language-scala">def debugPowerCode(
  x: Expr[Double],
  n: Expr[Int]
)(using QuoteContext): Expr[Double] =
  println(
    s"""powerCode
       |  x := ${x.show}
       |  n := ${n.show}""".stripMargin)
  val code = powerCode(x, n)
  println(s"  code := ${code.show}")
  code
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="working-with-varargs"></a><a href="#working-with-varargs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Working with Varargs</h3>
<p>Varargs in Scala are represented with <code>Seq</code>, hence when we write a macro with a <em>vararg</em>, it will be passed as an <code>Expr[Seq[T]]</code>.
It is possible to recover each individual argument (of type <code>Expr[T]</code>) using the <code>scala.quoted.Varargs</code> extractor.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumNow</span></span>(inline nums: <span class="hljs-type">Int</span>*): <span class="hljs-type">Int</span> =
  ${ sumCode(<span class="hljs-symbol">'nums</span>)  }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sumCode</span></span>(nums: <span class="hljs-type">Expr</span>[<span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>]])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Int</span>] =
  nums <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span>  <span class="hljs-type">Varargs</span>(numberExprs) =&gt; <span class="hljs-comment">// numberExprs: Seq[Expr[Int]]</span>
      <span class="hljs-keyword">val</span> numbers: <span class="hljs-type">Seq</span>[<span class="hljs-type">Int</span>] = numberExprs.map(_.unliftOrError)
      <span class="hljs-type">Expr</span>(numbers.sum)
    <span class="hljs-keyword">case</span> _ =&gt; report.error(
      <span class="hljs-string">"Expected explicit argument"</span> +
      <span class="hljs-string">"Notation `args: _*` is not supported."</span>, numbersExpr)
</code></pre>
<p>The extractor will match a call to <code>sumNow(1, 2, 3)</code> and extract a <code>Seq[Expr[Int]]</code> containing the code of each parameter.
But, if we try to match the argument of the call <code>sumNow(nums: _*)</code>, the extractor will not match.</p>
<p><code>Varargs</code> can also be used as a constructor, <code>Varargs(Expr(1), Expr(2), Expr(3))</code> will return a <code>Expr[Seq[Int]]</code>.
We will see how this can be useful later.</p>
<h2><a class="anchor" aria-hidden="true" id="complex-expressions"></a><a href="#complex-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Complex Expressions</h2>
<p>So far, we have only seen how to construct and destruct expressions that correspond to simple values.
In order to work with more complex expressions, Scala 3 offers different metaprogramming facilities ranging from</p>
<ul>
<li>additional constructors like <code>Expr.apply</code>,</li>
<li>over <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">quoted pattern matching</a>,</li>
<li>to a full <a href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html">reflection API</a>;</li>
</ul>
<p>each increasing in complexity and potentially losing safety guarantees.
It is generally recommended to prefer simple APIs over more advanced ones.
In the remainder of this section, we introduce some more additional constructors and destructors,
while subsequent chapters introduce the more advanced APIs.</p>
<h3><a class="anchor" aria-hidden="true" id="collections"></a><a href="#collections" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Collections</h3>
<p>We have seen how to convert a <code>List[Int]</code> into an <code>Expr[List[Int]]</code> using <code>Expr.apply</code>.
How about converting a <code>List[Expr[Int]]</code> into <code>Expr[List[Int]]</code>?
We mentioned that <code>Varargs.apply</code> can do this for sequences -- likewise for other collection types, corresponding methods are available:</p>
<ul>
<li><code>Expr.ofList</code>: Transform a <code>List[Expr[T]]</code> into <code>Expr[List[T]]</code></li>
<li><code>Expr.ofSeq</code>: Transform a <code>Seq[Expr[T]]</code> into <code>Expr[Seq[T]]</code> (just like <code>Varargs</code>)</li>
<li><code>Expr.ofTupleFromSeq</code>: Transform a <code>Seq[Expr[T]]</code> into <code>Expr[Tuple]</code></li>
<li><code>Expr.ofTuple</code>: Transform a <code>(Expr[T1], ..., Expr[Tn])</code> into <code>Expr[(T1, ..., Tn)]</code></li>
</ul>
<h3><a class="anchor" aria-hidden="true" id="simple-blocks"></a><a href="#simple-blocks" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple Blocks</h3>
<p>The constructor <code>Expr.block</code> provides a simple way to create a block of code <code>{ stat1; ...; statn; expr }</code>.
Its first arguments is a list with all the statements and the second argument is the expression at the end of the block.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span></span>(inline ignore: <span class="hljs-type">Boolean</span>, computation: =&gt; <span class="hljs-type">Unit</span>): <span class="hljs-type">Boolean</span> =
  ${ testCode(<span class="hljs-symbol">'ignore</span>, <span class="hljs-symbol">'computation</span>) }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">testCode</span></span>(ignore: <span class="hljs-type">Expr</span>[<span class="hljs-type">Boolean</span>], computation: <span class="hljs-type">Expr</span>[<span class="hljs-type">Unit</span>])(using <span class="hljs-type">QuoteContext</span>) =
  <span class="hljs-keyword">if</span> ignore.unliftOrError then <span class="hljs-type">Expr</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-type">Expr</span>.block(<span class="hljs-type">List</span>(computation), <span class="hljs-type">Expr</span>(<span class="hljs-literal">true</span>))
</code></pre>
<p>The <code>Expr.block</code> constructor is useful when we want to generate code contanining several side effects.
The macro call <code>test(false, EXPRESSION)</code> will generate <code>{ EXPRESSION; true}</code>, while the call <code>test(true, EXPRESSION)</code> will result in <code>false</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="simple-matching"></a><a href="#simple-matching" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Simple Matching</h3>
<p>The method <code>Expr.matches</code> can be used to check if one expression is equal to another.
With this method we could implement an <code>unlift</code> operation for <code>Expr[Boolean]</code> as follows.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unlift</span></span>(boolExpr: <span class="hljs-type">Expr</span>[<span class="hljs-type">Boolean</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>] =
  <span class="hljs-keyword">if</span> boolExpr.matches(<span class="hljs-type">Expr</span>(<span class="hljs-literal">true</span>)) then <span class="hljs-type">Some</span>(<span class="hljs-literal">true</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> boolExpr.matches(<span class="hljs-type">Expr</span>(<span class="hljs-literal">false</span>)) then <span class="hljs-type">Some</span>(<span class="hljs-literal">false</span>)
  <span class="hljs-keyword">else</span> <span class="hljs-type">None</span>
</code></pre>
<p>It may also be used to compare two user written expression.
Note, that <code>matches</code> only performs a limited amount of normalization and while for instance the Scala expression <code>2</code> matches the expression <code>{ 2 }</code>, this is <em>not the case</em> for the expression <code>{ val x: Int = 2; x }</code>.</p>
<h3><a class="anchor" aria-hidden="true" id="arbitrary-expressions"></a><a href="#arbitrary-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Arbitrary Expressions</h3>
<p>Last but not least, it is possible to create an <code>Expr[T]</code> from arbitary Scala code by enclosing it in <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">quotes</a>.
For example <code>'{ ${expr}; true }</code> will generate an <code>Expr[Int]</code> equivalent to <code>Expr.block(List(expr), Expr(true))</code>.
The subsequent section on <a href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">Quoted Code</a> presents quotes in more detail.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scala3-macro-tutorial/docs/tutorial/compile-time-operations.html"><span class="arrow-prev">← </span><span>Scala Compile-time Operations</span></a><a class="docs-next button" href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html"><span>Quoted Code</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#macros-treat-programs-as-values">Macros Treat Programs as Values</a><ul class="toc-headings"><li><a href="#macros-and-type-parameters">Macros and Type Parameters</a></li><li><a href="#defining-and-using-macros">Defining and Using Macros</a></li><li><a href="#example-statically-evaluating-power-with-macros">Example: Statically Evaluating <code>power</code> with Macros</a></li></ul></li><li><a href="#simple-expressions">Simple Expressions</a><ul class="toc-headings"><li><a href="#creating-expression-from-values">Creating Expression From Values</a></li><li><a href="#extracting-values-from-expressions">Extracting Values from Expressions</a></li><li><a href="#showing-expressions">Showing Expressions</a></li><li><a href="#working-with-varargs">Working with Varargs</a></li></ul></li><li><a href="#complex-expressions">Complex Expressions</a><ul class="toc-headings"><li><a href="#collections">Collections</a></li><li><a href="#simple-blocks">Simple Blocks</a></li><li><a href="#simple-matching">Simple Matching</a></li><li><a href="#arbitrary-expressions">Arbitrary Expressions</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#224951"><section class="sitemap"><a href="/scala3-macro-tutorial/" class="nav-home"><img src="/scala3-macro-tutorial/img/dotty-logo-white.svg" alt="Scala 3 Macro Tutorial" width="66" height="58"/></a><div><h5>Docs</h5><a href="
                /scala3-macro-tutorial/docs/tutorial/introduction.html">Tutorial</a><a href="
                /scala3-macro-tutorial/docs/contributing.html">Contribute</a><a href="
                /scala3-macro-tutorial/docs/faq.html">FAQ</a></div><div><h5>Community</h5><a href="https://gitter.im/lampepfl/dotty" target="_blank">Chat on Gitter</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/lampepfl/scala3-macro-tutorial" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2020 LAMP EPFL</section></footer></div></body></html>