<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Quoted Code · Scala 3 Macro Tutorial</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="A quoted code block `&#x27;{ ... }` is syntactacaly similar to a string quote `&quot; ... &quot;` with the diffecence that the fist contains typed code."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Quoted Code · Scala 3 Macro Tutorial"/><meta property="og:type" content="website"/><meta property="og:url" content="https://lampepfl.github.io//scala3-macro-tutorial/index.html"/><meta property="og:description" content="A quoted code block `&#x27;{ ... }` is syntactacaly similar to a string quote `&quot; ... &quot;` with the diffecence that the fist contains typed code."/><meta property="og:image" content="https://lampepfl.github.io//scala3-macro-tutorial/img/scalacenter2x.png"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://lampepfl.github.io//scala3-macro-tutorial/img/scalacenter2x.png"/><link rel="shortcut icon" href="/scala3-macro-tutorial/img/dotty-logo.svg"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lobster&amp;display=swap"/><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700|Fira+Code:400,700&amp;display=fallback"/><script src="/scala3-macro-tutorial/js/scrollSpy.js"></script><link rel="stylesheet" href="/scala3-macro-tutorial/css/main.css"/><script src="/scala3-macro-tutorial/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/scala3-macro-tutorial/"><img class="logo" src="/scala3-macro-tutorial/img/dotty-logo-white.svg" alt="Scala 3 Macro Tutorial"/><h2 class="headerTitleWithLogo">Scala 3 Macro Tutorial</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/scala3-macro-tutorial/docs/tutorial/introduction.html" target="_self">Tutorial</a></li><li class=""><a href="/scala3-macro-tutorial/docs/contributing.html" target="_self">Contribute</a></li><li class=""><a href="https://github.com/lampepfl/scala3-macro-tutorial" target="_blank">GitHub</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Tutorial</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Tutorial</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/introduction.html">Introduction</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/inline.html">Inline</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/scala-3-macros.html">Scala 3 macros</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/quoted-code.html">Quoted Code</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html">TASTy Reflection</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Other</h3><ul class=""><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/faq.html">FAQ</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/best-practices.html">Best practices</a></li><li class="navListItem"><a class="navItem" href="/scala3-macro-tutorial/docs/compile-time-operations.html">Compile-time operations</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/lampepfl/scala3-macro-tutorial/edit/master/docs/tutorial/quotes.md" target="_blank" rel="noreferrer noopener">Edit</a><h1 id="__docusaurus" class="postHeaderTitle">Quoted Code</h1></header><article><div><span><p>A quoted code block <code>'{ ... }</code> is syntactacaly similar to a string quote <code>&quot; ... &quot;</code> with the diffecence that the fist contains typed code.
To insert a code into other code we use the <code>$expr</code> or <code>${ expr }</code> where <code>expr</code> is of type <code>Expr[T]</code>.
Intuitively, the code directly within the quote is not excecuted now, while the code within the splices is evaluated and their results are then spliced int the sourounding expression.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">val</span> msg = <span class="hljs-type">Expr</span>(<span class="hljs-string">"Hello"</span>)
<span class="hljs-keyword">val</span> printHello = '{ print($hello) }
println(printHello.show) <span class="hljs-comment">// print("Hello")</span>
</code></pre>
<p>In general, the quote delays the excecution while the splice makes it happen before the sourounding code.
This generalization allows us to also give meeining to a <code>${ .. }</code> that is not within a quote, this evaluate the code within the splice at compile-time and place the result in the generated code.
Due to some thechincal considerations we only allow it directly within <code>inline</code> definitions that we call a <a href="/scala3-macro-tutorial/docs/tutorial/scala-3-macros.html">macro</a>.</p>
<p>It is possible to write a quote within a quote, but usually when we write macros we do not encounter such code.</p>
<h2><a class="anchor" aria-hidden="true" id="level-consitency"></a><a href="#level-consitency" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Level consitency</h2>
<p>One cannot simple write any arbitrary code within quotes and within splices.
A part of the program will live at compile-time and the other will live at runtime.
Consider the folllowing ill-consturucted code.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myBadCounter1</span></span>(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Int</span>] = {
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>
  '{ x += <span class="hljs-number">1</span>; x }
}
</code></pre>
<p>The problem with this code is that <code>x</code> exists durring compilation, but then we try to use it after the compiler has finished (maybe even in another machine).
Clearly it would be impossible to access its value and update it.</p>
<p>Now consider the dual version, where we define the variable at runtime and try to access it at compile-time.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myBadCounter2</span></span>(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Int</span>] = '{
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>
  ${ x += <span class="hljs-number">1</span>; <span class="hljs-symbol">'x</span> }
}
</code></pre>
<p>Clearly, this should work as the variable does not exist yet.
To make sure you can only write programs that do not contain these kinds of probems we restrict the set of references to variable and other definitions.</p>
<p>We introduce <em>levels</em> as a count of the number of quotes minus the number of splices surrounding an expression or definition.</p>
<pre><code class="hljs css language-scala"><span class="hljs-comment">// level 0</span>
'{ <span class="hljs-comment">// level 1</span>
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">0</span>
  ${ <span class="hljs-comment">// level 0</span>
    x += <span class="hljs-number">1</span> 
    <span class="hljs-symbol">'x</span> <span class="hljs-comment">// level 1 </span>
  }
}
</code></pre>
<p>The system will allow at any level references to global definitions such as <code>println</code>, but will restrict refrences to local definitions.
A local definition can only be accessed if it is defined a the same level as its reference.
This will catch the errors in <code>myBadCounter1</code> and <code>myBadCounter2</code>.</p>
<p>Eventhoug we cannot rever to variable inside of a quote, we can still pass its current value to it by lifting the value to an expression using <code>Expr.apply</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="generics"></a><a href="#generics" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Generics</h2>
<p>When using type parameters or other kinds of abstract types with quoted code we will need to keep track of some of these types explicitly.
Scala uses erased-types semantics for its generics.
This implies that types are removed from the program when compiling and the runtime does not have to track all types at runtime.</p>
<p>Consider the following code</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalAndUse</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]) = '{
  <span class="hljs-keyword">val</span> x2: <span class="hljs-type">T</span> = $x <span class="hljs-comment">// error</span>
  ... <span class="hljs-comment">// use x2</span>
}
</code></pre>
<p>Here we will get an error telling us that we are missing a contextual <code>Type[T]</code>.
Therefore we can easely fix it by writing</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalAndUse</span></span>[<span class="hljs-type">X</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">X</span>])(using <span class="hljs-type">Type</span>[<span class="hljs-type">X</span>])(using <span class="hljs-type">QuoteContext</span>) = '{
  <span class="hljs-keyword">val</span> x2: <span class="hljs-type">X</span> = $x
  ... <span class="hljs-comment">// use x2</span>
}
</code></pre>
<p>This code will be equivalent to the more verbose</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalAndUse</span></span>[<span class="hljs-type">X</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">X</span>])(using t: <span class="hljs-type">Type</span>[<span class="hljs-type">X</span>])(using <span class="hljs-type">QuoteContext</span>) = '{
  <span class="hljs-keyword">val</span> x2: t.<span class="hljs-type">T</span> = $x
  ... <span class="hljs-comment">// use x2</span>
}
</code></pre>
<p>Note that <code>Type</code> has a type member called <code>T</code> that refers to the type held within the <code>Type</code>, in this case <code>t.T</code> is <code>X</code>.
Note that even if we used it implicitly is better to keep it contextual as some changes inside the quote may require it.
The less verbose version is usually the best way to write the types as it is much simpler to read.
In some cases, we will not know statically the type within the <code>Type</code> and will need to use the <code>.T</code> to refer to it.</p>
<p>When do we need this extra <code>Type</code> parameter?</p>
<ul>
<li>When a type is abstract and it is used in a level that is larger than the current level.</li>
</ul>
<p>When you add a <code>Type</code> contextual parameter to a method you will either get it from another context parameter or implicitly with a call to <code>Type.apply</code>.</p>
<pre><code class="hljs css language-scala">evalAndUse(<span class="hljs-type">Expr</span>(<span class="hljs-number">3</span>))
<span class="hljs-comment">// is equivalent to</span>
evalAndUse[<span class="hljs-type">Int</span>](<span class="hljs-type">Expr</span>(<span class="hljs-number">3</span>))(using <span class="hljs-type">Type</span>[<span class="hljs-type">Int</span>])
</code></pre>
<p>As you may have guessed, not every type is can be used in this <code>Type[..]</code> out of the box.
We cannot recover abstract types that have already been erased.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">evalAndUse</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>])(using <span class="hljs-type">QuoteContext</span>) =
  given <span class="hljs-type">Type</span>[<span class="hljs-type">T</span>] = <span class="hljs-type">Type</span>[<span class="hljs-type">T</span>] <span class="hljs-comment">// error</span>
  '{
    <span class="hljs-keyword">val</span> x2: <span class="hljs-type">T</span> = $x
    ... <span class="hljs-comment">// use x2</span>
  }
</code></pre>
<p>But we can write more complex types that depend on these abstract types.
For example, if we look for or construct explicitly a <code>Type[List[T]]</code>, then the system will require a <code>Type[T]</code> in the current context to compile.</p>
<p>Good code should only add <code>Type</code> to the context parameters and never use them explicitly.
Explicit use is useful while debugging at the cost of conciseness and clarity.</p>
<h2><a class="anchor" aria-hidden="true" id="liftables"></a><a href="#liftables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Liftables</h2>
<p>The <code>Expr.apply</code> method uses intances of <code>Liftable</code> to perform the lifting.</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Expr</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">T</span>)(using <span class="hljs-type">QuoteContext</span>, <span class="hljs-type">Liftable</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>] =
    summon[<span class="hljs-type">Liftable</span>[<span class="hljs-type">T</span>]].toExpr(x)
</code></pre>
<p><code>Liftable</code> is defined as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Liftable</span>[<span class="hljs-type">T</span>]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toExpr</span></span>(x: <span class="hljs-type">T</span>): <span class="hljs-type">QuoteContext</span> ?=&gt; <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]
</code></pre>
<p>The <code>toExpr</code> method will take a value <code>T</code> and generate code that will construct a copy of this value at runtime.</p>
<p>We can define our own <code>Liftable</code>s like:</p>
<pre><code class="hljs css language-scala">given <span class="hljs-type">Liftable</span>[<span class="hljs-type">Boolean</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Liftable</span>[<span class="hljs-type">Boolean</span>] {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toExpr</span></span>(x: <span class="hljs-type">Boolean</span>) =
    <span class="hljs-keyword">if</span> x then '{<span class="hljs-literal">true</span>}
    <span class="hljs-keyword">else</span> '{<span class="hljs-literal">false</span>}
}

given <span class="hljs-type">Liftable</span>[<span class="hljs-type">StringContext</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Liftable</span>[<span class="hljs-type">StringContext</span>] {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">toExpr</span></span>(x: <span class="hljs-type">StringContext</span>) =
    <span class="hljs-keyword">val</span> parts = <span class="hljs-type">Varargs</span>(stringContext.parts.map(<span class="hljs-type">Expr</span>(_)))
    '{ <span class="hljs-type">StringContext</span>($parts: _*) }
}
</code></pre>
<p>The <code>Varargs</code> constructor just creates an <code>Expr[Seq[T]]</code> which we can efficiently splice as a varargs.
In general any sequence can be spliced with <code>$mySeq: _*</code> to splice it a varargs.</p>
<h2><a class="anchor" aria-hidden="true" id="quoted-patterns"></a><a href="#quoted-patterns" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Quoted patterns</h2>
<p>Quotes can also be used to check if an expression is equivalent to another or deconstruct an expression into it parts.</p>
<h3><a class="anchor" aria-hidden="true" id="matching-exact-expression"></a><a href="#matching-exact-expression" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching exact expression</h3>
<p>The simples thing we can do is to check if an expression matches another know expression.
Bellow we show how we can match some expressions using <code>case '{...} =&gt;</code></p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueOfBoolean</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Boolean</span>])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>] =
  x <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> '{ <span class="hljs-literal">true</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-literal">true</span>)
    <span class="hljs-keyword">case</span> '{ <span class="hljs-literal">false</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-literal">false</span>)
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueOfBooleanOption</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>]])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>]] =
  x <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">Some</span>(<span class="hljs-literal">true</span>) } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">Some</span>(<span class="hljs-literal">true</span>))
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">Some</span>(<span class="hljs-literal">false</span>) } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">Some</span>(<span class="hljs-literal">false</span>))
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">None</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">None</span>)
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="matching-partial-expression"></a><a href="#matching-partial-expression" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching partial expression</h3>
<p>To make thing more compact, we can also match patially the expression using a <code>$</code> to match arbitrarry code and extract it.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueOfBooleanOption</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>]])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>]] =
  x <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">Some</span>($boolExpr) } =&gt; <span class="hljs-type">Some</span>(valueOfBoolean(boolExpr))
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">None</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">None</span>)
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="matching-types-of-expression"></a><a href="#matching-types-of-expression" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching types of expression</h3>
<p>We can also match agains code of an arbitrarry type <code>T</code>.
Bellow we match agains <code>$x</code> of type <code>T</code> and we get out an <code>x</code> of type <code>Expr[T]</code>.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exprOfOption</span></span>[<span class="hljs-type">T</span>: <span class="hljs-type">Type</span>](x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]] =
  x <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">Some</span>($x) } =&gt; <span class="hljs-type">Some</span>(x) <span class="hljs-comment">// x: Expr[T]</span>
    <span class="hljs-keyword">case</span> '{ <span class="hljs-type">None</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">None</span>)
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
</code></pre>
<p>We can also check for the type of an expression</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueOf</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Any</span>])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Any</span>] =
  x <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> '{ $x: <span class="hljs-type">Boolean</span> } =&gt; valueOfBoolean(x) <span class="hljs-comment">// x: Expr[Boolean]</span>
    <span class="hljs-keyword">case</span> '{ $x: <span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>] }  =&gt; valueOfBooleanOption(x) <span class="hljs-comment">// x: Expr[Option[Boolean]]</span>
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
</code></pre>
<p>Or similarly for an some subexpression</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> '{ <span class="hljs-type">Some</span>($x: <span class="hljs-type">Boolean</span>) } =&gt; <span class="hljs-comment">// x: Expr[Boolean]</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="matching-reciver-of-methods"></a><a href="#matching-reciver-of-methods" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching reciver of methods</h3>
<p>When we want to match the reciver of a method we need to explicitly state its type</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> '{ ($ls: <span class="hljs-type">List</span>[<span class="hljs-type">Int</span>]).sum } =&gt;
</code></pre>
<p>If we would have written <code>$ls.sum</code> we would not have been able to know the type of <code>ls</code> and which <code>sum</code> method we are calling.</p>
<p>Another common case where we need type annotations is for infix operations.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">case</span> '{ ($x: <span class="hljs-type">Int</span>) + ($y: <span class="hljs-type">Int</span>) } =&gt;
<span class="hljs-keyword">case</span> '{ ($x: <span class="hljs-type">Double</span>) + ($y: <span class="hljs-type">Double</span>) } =&gt;
<span class="hljs-keyword">case</span> ...
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="matching-function-expressions"></a><a href="#matching-function-expressions" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching function expressions</h3>
<p><em>Coming soon</em></p>
<h3><a class="anchor" aria-hidden="true" id="matching-types"></a><a href="#matching-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Matching types</h3>
<p><em>Coming soon</em></p>
<h2><a class="anchor" aria-hidden="true" id="unliftables"></a><a href="#unliftables" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Unliftables</h2>
<p>The <code>Expr.unlift</code>, <code>Expr.unlift.orError</code> <code>Unlifted.unapply</code> method uses intances of <code>Unliftable</code> to perform the unlifting.</p>
<pre><code class="hljs css language-scala">extension [<span class="hljs-type">T</span>](expr: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]):
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unlift</span></span>(using <span class="hljs-type">QuoteContext</span>)(using unlift: <span class="hljs-type">Unliftable</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">T</span>] =
    unlift(expr)

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unliftOrError</span></span>(using <span class="hljs-type">QuoteContext</span>)(using unlift: <span class="hljs-type">Unliftable</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> =
    unlift(expr).getOrElse(eport.throwError(<span class="hljs-string">"..."</span>, expr))
end extension

<span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Unlifted</span></span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>[<span class="hljs-type">T</span>](expr: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>])(using <span class="hljs-type">QuoteContext</span>)(using unlift: <span class="hljs-type">Unliftable</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Option</span>[<span class="hljs-type">T</span>] =
    unlift(expr)
</code></pre>
<p><code>Unliftable</code> is defined as follows:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Unliftable</span>[<span class="hljs-type">T</span>]</span>:
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromExpr</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">T</span>]
</code></pre>
<p>The <code>toExpr</code> method will take a value <code>T</code> and generate code that will construct a copy of this value at runtime.</p>
<p>We can define our own <code>Uniftable</code>s like:</p>
<pre><code class="hljs css language-scala">given <span class="hljs-type">Unliftable</span>[<span class="hljs-type">Boolean</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Unliftable</span>[<span class="hljs-type">Boolean</span>] {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromExpr</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">Boolean</span>])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">Boolean</span>] =
    x <span class="hljs-keyword">match</span>
      <span class="hljs-keyword">case</span> '{ <span class="hljs-literal">true</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-literal">true</span>)
      <span class="hljs-keyword">case</span> '{ <span class="hljs-literal">false</span> } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-literal">false</span>)
      <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
}

given <span class="hljs-type">Unliftable</span>[<span class="hljs-type">StringContext</span>] = <span class="hljs-keyword">new</span> <span class="hljs-type">Unliftable</span>[<span class="hljs-type">StringContext</span>] {
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fromExpr</span></span>(x: <span class="hljs-type">Expr</span>[<span class="hljs-type">StringContext</span>])(using qctx: <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Option</span>[<span class="hljs-type">StringContext</span>] = x <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> '{ <span class="hljs-keyword">new</span> <span class="hljs-type">StringContext</span>(${<span class="hljs-type">Varargs</span>(<span class="hljs-type">Consts</span>(args))}: _*) } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">StringContext</span>(args: _*))
    <span class="hljs-keyword">case</span> '{     <span class="hljs-type">StringContext</span>(${<span class="hljs-type">Varargs</span>(<span class="hljs-type">Consts</span>(args))}: _*) } =&gt; <span class="hljs-type">Some</span>(<span class="hljs-type">StringContext</span>(args: _*))
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">None</span>
  }
}
</code></pre>
<p>Note that we handled two cases for the <code>StringContext</code>.
As it is a <code>case class</code> it can be created with the <code>new StringContext</code> or with the <code>StringContext.apply</code> in the companion object.
We also used the <code>Varargs</code> extractor to match the arguments of type <code>Expr[Seq[String]]</code> into a <code>Seq[Expr[String]]</code>.
Then we used the <code>Consts</code> to match known constants in the <code>Seq[Expr[String]]</code> to get a <code>Seq[String]</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="the-quotecontext"></a><a href="#the-quotecontext" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The QuoteContext</h2>
<p>The <code>QuoteContext</code> is the main entry point for the creation of all quotes.
This contex is usually just passed around through contextual abstractions (<code>using</code> and <code>?=&gt;</code>).
Each quote scope will provide have its own <code>QuoteContext</code>.
New scopes are intoduced each time a splice is intoduced <code>${...}</code>.
Though it looks like a splice takes an expression as argument, it actually takes a <code>QuoteContext ?=&gt; Expr[T]</code>.
Therfore we could actually write it explicitly as <code>${ (using q) =&gt; ... }</code>, this might be useful when debuging to avoid generated names for these scopes.</p>
<p>The method <code>scala.quoted.qctx</code> provides a simple way to use the current <code>QuoteContext</code> without naming it.
It is usually imported along with the <code>QuoteContext</code> using <code>import scala.quoted._</code>.</p>
<pre><code class="hljs css language-scala">${ (using q1) =&gt; body(using q1) }
<span class="hljs-comment">// equivalent to</span>
${ body(using qctx) }
</code></pre>
<p>If you explicitly name a <code>QuoteContext</code> <code>qctx</code> you will shadow this definition.</p>
<p>When we write a top level splice in a macro we are calling something similar to the following definition.
This splice will provide the initial <code>QuoteContext</code> asociated with the macro expansion.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">$</span></span>[<span class="hljs-type">T</span>](x: <span class="hljs-type">QuoteContext</span> ?=&gt; <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> = ...
</code></pre>
<p>When we have a splice within a quote, the inner quote context will depend on the outer one.
This link is represented using the <code>QuoteContext.Nested</code> type.
This relation tells us that it is safe to use expressions createed with <code>q1</code> within the scope of <code>q2</code> but not the other way around (this constraint is statically checked yet).</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span></span>(using q1: <span class="hljs-type">QuoteContext</span>) = '{
  ${ (using q2: q1.<span class="hljs-type">Nested</span>) ?=&gt;
      ...
  }
}
</code></pre>
<p>We can imagine that a nested splice is like the following method, where <code>ctx</code> is the context recived by the sourounding quote.</p>
<pre><code class="hljs css language-scala"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">$</span></span>[<span class="hljs-type">T</span>](using ctx: <span class="hljs-type">QuoteContext</span>)(x: ctx.<span class="hljs-type">Nested</span> ?=&gt; <span class="hljs-type">Expr</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">T</span> = ...
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="β-reduction"></a><a href="#β-reduction" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>β-reduction</h2>
<p>When we have a lambda applied to an argument in a quote <code>'{ ((x: Int) =&gt; x + x)(y) }</code> we do not reduce it within the quote, the code is kept as is.
There is an optimization that β-reduce all lambdas directly applied to parameters to aboid the creation of the closure.
This will not be visible from the quotes perspective.</p>
<p>Sometime it is useful to perform this β-reduction on the quotes directly.
We provide the function <code>Expr.betaReduce[T]</code> that recives an <code>Expr[T]</code> and β-reduce if it ccontains a directly applied lambda.</p>
<pre><code class="hljs css language-scala"><span class="hljs-type">Expr</span>.betaReduce('{ ((x: <span class="hljs-type">Int</span>) =&gt; x + x)(y) }) <span class="hljs-comment">// returns '{ val x = y; x + x }</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="summon-values"></a><a href="#summon-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summon values</h2>
<p>There are two ways to summon values in a macro.
The first is to have a <code>using</code> parameter in the inline method that is passed explicitly to the macro implementation.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setFor</span></span>[<span class="hljs-type">T</span>](using ord: <span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]): <span class="hljs-type">Set</span>[<span class="hljs-type">T</span>] =
  ${ setForCode[<span class="hljs-type">T</span>](<span class="hljs-symbol">'ord</span>) }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setForCode</span></span>[<span class="hljs-type">T</span>: <span class="hljs-type">Type</span>](ord: <span class="hljs-type">Expr</span>[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]])(using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Set</span>[<span class="hljs-type">T</span>]] =
  '{ <span class="hljs-type">TreeSet</span>.empty[<span class="hljs-type">T</span>](using $ord) }
</code></pre>
<p>In this scenario, the context parameter is found before the macro is expanded.
If not found, the macro will not expand.</p>
<p>The second way is using <code>Expr.summon</code>.
This allows to programatically search for distinct given expressions.
The following example is similar to the previous example.</p>
<pre><code class="hljs css language-scala">inline <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setFor</span></span>[<span class="hljs-type">T</span>]: <span class="hljs-type">Set</span>[<span class="hljs-type">T</span>] =
  ${ setForCode[<span class="hljs-type">T</span>] }

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setForCode</span></span>[<span class="hljs-type">T</span>: <span class="hljs-type">Type</span>](using <span class="hljs-type">QuoteContext</span>): <span class="hljs-type">Expr</span>[<span class="hljs-type">Set</span>[<span class="hljs-type">T</span>]] =
  <span class="hljs-keyword">import</span> scala.collection.immutable._
  <span class="hljs-type">Expr</span>.summon[<span class="hljs-type">Ordering</span>[<span class="hljs-type">T</span>]] <span class="hljs-keyword">match</span>
    <span class="hljs-keyword">case</span> <span class="hljs-type">Some</span>(ord) =&gt; '{ <span class="hljs-type">TreeSet</span>.empty[<span class="hljs-type">T</span>](using $ord) }
    <span class="hljs-keyword">case</span> _ =&gt; '{ <span class="hljs-type">HashSet</span>.empty[<span class="hljs-type">T</span>] }
</code></pre>
<p>The difference is that in this sencario we do start expanding the maro before the implicit search failure and we can write arbirtary code to hande the case where it is not found.
Here we used <code>HashSet</code> and another valid implemetation that does not need the <code>Ordering</code>.</p>
<p>⮕ <a href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html">Continue to TASTy Reflection</a></p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/scala3-macro-tutorial/docs/tutorial/scala-3-macros.html"><span class="arrow-prev">← </span><span>Scala 3 macros</span></a><a class="docs-next button" href="/scala3-macro-tutorial/docs/tutorial/tasty-reflection.html"><span>TASTy Reflection</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#level-consitency">Level consitency</a></li><li><a href="#generics">Generics</a></li><li><a href="#liftables">Liftables</a></li><li><a href="#quoted-patterns">Quoted patterns</a><ul class="toc-headings"><li><a href="#matching-exact-expression">Matching exact expression</a></li><li><a href="#matching-partial-expression">Matching partial expression</a></li><li><a href="#matching-types-of-expression">Matching types of expression</a></li><li><a href="#matching-reciver-of-methods">Matching reciver of methods</a></li><li><a href="#matching-function-expressions">Matching function expressions</a></li><li><a href="#matching-types">Matching types</a></li></ul></li><li><a href="#unliftables">Unliftables</a></li><li><a href="#the-quotecontext">The QuoteContext</a></li><li><a href="#β-reduction">β-reduction</a></li><li><a href="#summon-values">Summon values</a></li></ul></nav></div><footer class="nav-footer" id="footer" style="background-color:#224951"><section class="sitemap"><a href="/scala3-macro-tutorial/" class="nav-home"><img src="/scala3-macro-tutorial/img/dotty-logo-white.svg" alt="Scala 3 Macro Tutorial" width="66" height="58"/></a><div><h5>Docs</h5><a href="
                /scala3-macro-tutorial/docs/tutorial/introduction.html">Get started</a><a href="
                /scala3-macro-tutorial/docs/contributing.html">Contribute</a><a href="
                /scala3-macro-tutorial/docs/faq.html">FAQ</a></div><div><h5>Community</h5><a href="https://gitter.im/scala/center" target="_blank">Chat on Gitter</a><a href="https://users.scala-lang.org/" target="_blank">Discuss on Scala Users</a></div><div><h5>More</h5><a href="https://github.com/lampepfl/scala3-macro-tutorial" target="_blank">GitHub</a></div></section><section class="copyright">Copyright © 2020 Scala Center</section></footer></div></body></html>